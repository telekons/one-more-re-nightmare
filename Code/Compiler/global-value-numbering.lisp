(in-package :one-more-re-nightmare)

(defstruct gvn-set
  number
  position-delta
  registers)

(defvar *gvn-gensym-counter*)
(defvar *initial-gvn-pool* '())
(defun fresh-gvn-number ()
  (incf *gvn-gensym-counter*)
  *gvn-gensym-counter*)

(defun compute-global-value-numbers (initial-state dfa)
  (let ((work-list (list (gethash initial-state dfa)))
        (input-pools (make-hash-table))
        (output-pools (make-hash-table))
        (*gvn-gensym-counter* 0))
    ;; Iterate until we reach a fixed point.
    (labels ((update-successors (state)
               (dolist (transition (state-transitions state))
                 (pushnew (transition-next-state transition) work-list)))
             (available-incoming-pools (state)
               (loop for transition in (incoming-transitions state)
                     when (nth-value 1 (gethash transition output-pools))
                       collect (gethash transition output-pools)))
             (has-input-pool-p (state)
               (nth-value 1 (gethash state input-pools)))
             (input (state)
               (gethash state input-pools)))
      (loop
        (when (null work-list)
          (return))
        (let* ((state (pop work-list))
               (pools (available-incoming-pools state))
               (confluence (if (null pools)
                               *initial-gvn-pool*
                               (reduce #'gvn-confluence pools))))
          (unless (and (has-input-pool-p state)
                       (gvn-similar confluence (input state)))
            (format t "~&updating ~s~&from ~:s~&to ~:s~&due to ~:s"
                    state (input state) confluence pools)
            (setf (gethash state input-pools) confluence)
            (dolist (transition (state-transitions state))
              (setf (gethash transition output-pools)
                    (gvn-transfer transition confluence)))
            (update-successors state)))))
    (values input-pools output-pools)))

(defun gvn-confluence (pool1 pool2)
  (let ((new-pool '()))
    (dolist (set1 pool1)
      (dolist (set2 pool2)
        (let ((both (intersection (gvn-set-registers set1)
                                  (gvn-set-registers set2)
                                  :test #'equal)))
          (unless (null both)
            (push (make-gvn-set
                   ;; Reuse a number if possible.
                   :number (if (and (= (gvn-set-number set1)
                                       (gvn-set-number set2))
                                    (eq (gvn-set-registers set1)
                                        (gvn-set-registers set2)))
                               (gvn-set-number set1)
                               (fresh-gvn-number))
                   :position-delta (if (eql (gvn-set-position-delta set1)
                                            (gvn-set-position-delta set2))
                                       (gvn-set-position-delta set1)
                                       nil)
                   :registers both)
                  new-pool)))))
    new-pool))

(defun gvn-transfer (transition pool)
  (flet ((bump-set (set)
           (make-gvn-set
            :number (gvn-set-number set)
            :position-delta (if (null (gvn-set-position-delta set))
                                nil
                                (1+ (gvn-set-position-delta set)))
            :registers (gvn-set-registers set))))
    (let ((new-pool (mapcar #'bump-set pool))
          (position-set (make-gvn-set
                         :number (fresh-gvn-number)
                         :position-delta 0
                         :registers '())))
      (push position-set new-pool)
      (labels ((find-set (register &key (error-p t))
                 (or (find register new-pool
                           :test (lambda (e set)
                                   (find e (gvn-set-registers set)
                                         :test #'equal)))
                     (if error-p (error "No set for register ~s." register) nil)))
               (remove-info (register)
                 (let ((set (find-set register :error-p nil)))
                   (unless (null set)
                     (alexandria:removef (gvn-set-registers set)
                                         register
                                         :test #'equal))))
               (associate-with-position (register)
                 (push register (gvn-set-registers position-set)))
               (associate-registers (new existing)
                 (push new (gvn-set-registers (find-set existing)))))
        (loop for (register . source) in (transition-tags-to-set transition)
              unless (equal register source)
                do (remove-info register)
                   (if (eql source 'position)
                       (associate-with-position register)
                       (associate-registers register source)))
        (remove '() new-pool :key #'gvn-set-registers)))))

(defun gvn-similar (pool1 pool2)
  (unless (= (length pool1) (length pool2))
    (return-from gvn-similar nil))
  (let ((remaining-in-pool2 pool2))
    (dolist (set pool1)
      (flet ((similar-set-p (set2)
               (and (eql (gvn-set-position-delta set)
                         (gvn-set-position-delta set2))
                    (null (set-exclusive-or
                           (gvn-set-registers set)
                           (gvn-set-registers set2)
                           :test #'equal)))))
        (let ((similar-set (find-if #'similar-set-p remaining-in-pool2)))
          (when (null similar-set)
            (return-from gvn-similar nil))
          (alexandria:removef remaining-in-pool2 similar-set)))))
  t)

(defun test-gvn (re)
  (let* ((machine (make-search-machine (parse-regular-expression re)))
         (dfa (make-dfa-from-expression machine)))
    (compute-predecessor-lists dfa)
    (multiple-value-bind (ins outs)
        (compute-global-value-numbers machine dfa)
      (let ((seen '()))
        (maphash (lambda (state pool)
                   (declare (ignore state))
                   (dolist (set pool)
                     (when (null (gvn-set-position-delta set))
                       (pushnew (gvn-set-number set) seen))))
                 ins)
        (format t "~&~d value~:p" (length seen)))
      (values ins outs))))
